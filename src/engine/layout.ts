import type { SceneModel, SceneNode } from "../types";

export function computeLayoutPositions(
    model: SceneModel,
    layout?: { mode?: "radial" | "grid" | "force" | "spherical"; radius?: number; chapterRingSpacing?: number }
): SceneModel {
    const mode = layout?.mode ?? "spherical";
    const radius = layout?.radius ?? 2000;
    const ringSpacing = layout?.chapterRingSpacing ?? 15;

    const childrenMap = new Map<string, SceneNode[]>();
    const roots: SceneNode[] = [];
    const books: SceneNode[] = [];

    // Build hierarchy
    for (const n of model.nodes) {
        if (n.level === 2) books.push(n); // Collect books for spherical layout
        if (n.parent) {
            const children = childrenMap.get(n.parent) ?? [];
            children.push(n);
            childrenMap.set(n.parent, children);
        } else {
            roots.push(n);
        }
    }

    const updatedNodes = model.nodes.map((n) => ({ ...n, meta: { ...(n.meta ?? {}) } }));
    const updatedNodeMap = new Map(updatedNodes.map(n => [n.id, n]));
    const leafCounts = new Map<string, number>();

    // Helper: Count leaves
    function getLeafCount(node: SceneNode): number {
        const children = childrenMap.get(node.id) ?? [];
        if (children.length === 0) {
            leafCounts.set(node.id, 1);
            return 1;
        }
        let count = 0;
        for (const c of children) count += getLeafCount(c);
        leafCounts.set(node.id, count);
        return count;
    }
    roots.forEach(getLeafCount);

    // --- SPHERICAL MODE ---
    if (mode === "spherical") {
        // Sort books by ID (Biblical order if IDs are sequential/correct)
        // Assuming IDs generated by adapter are consistent B:GEN, B:EXO... 
        // Note: Adapter IDs are B:Key. Alphabetical might not be Biblical. 
        // Ideally we trust the input order or add an 'order' field. 
        // For now, we rely on the order they appear in 'books' array which comes from 'nodes' array 
        // which comes from traversal order in adapter -> Correct.
        
        let currentAzimuth = 0;
        const totalBooksWeight = books.reduce((sum, b) => sum + (leafCounts.get(b.id) ?? 1), 0);
        
        // Pseudo-random generator for deterministic constellations
        let seed = 1234;
        const random = () => {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        };

        for (const book of books) {
            const weight = leafCounts.get(book.id) ?? 1;
            const angleSpan = (weight / totalBooksWeight) * Math.PI * 2;
            const centerAzimuth = currentAzimuth + angleSpan / 2;
            
            // Random Elevation between 20° (horizon) and 80° (near zenith)
            // 0 is horizon, PI/2 is zenith.
            const centerElevation = (20 + random() * 60) * (Math.PI / 180);

            const uBook = updatedNodeMap.get(book.id)!;
            
            // Place Book Label at center
            // Spherical to Cartesian (Y up)
            // x = r * cos(el) * cos(az)
            // y = r * sin(el)
            // z = r * cos(el) * sin(az)
            const r = radius;
            (uBook.meta as any).x = r * Math.cos(centerElevation) * Math.cos(centerAzimuth);
            (uBook.meta as any).y = r * Math.sin(centerElevation);
            (uBook.meta as any).z = r * Math.cos(centerElevation) * Math.sin(centerAzimuth);

            // Place Chapters (Constellation)
            const chapters = childrenMap.get(book.id) ?? [];
            chapters.forEach((chap) => {
                const uChap = updatedNodeMap.get(chap.id)!;
                
                // Scatter around center
                // +/- 5 degrees azimuth, +/- 5 degrees elevation
                const spread = 0.15; // roughly 8-10 degrees
                const az = centerAzimuth + (random() - 0.5) * spread;
                const el = centerElevation + (random() - 0.5) * spread;

                (uChap.meta as any).x = r * Math.cos(el) * Math.cos(az);
                (uChap.meta as any).y = r * Math.sin(el);
                (uChap.meta as any).z = r * Math.cos(el) * Math.sin(az);
            });

            currentAzimuth += angleSpan;
        }

        // Bubble up positions to Divisions (L1) and Testaments (L0)
        // Helper to centroid children
        const setCentroid = (node: SceneNode) => {
            const children = childrenMap.get(node.id) ?? [];
            if (children.length === 0) return;

            let x = 0, y = 0, z = 0;
            let count = 0;
            for (const child of children) {
                // Ensure child has position (recurse if needed, but we built bottom-up sort of)
                // Actually books are done. Divisions need books. Testaments need divisions.
                // So we can just process L1 then L0.
                const uChild = updatedNodeMap.get(child.id)!;
                const cx = (uChild.meta as any).x;
                if (typeof cx === 'number') {
                    x += cx;
                    y += (uChild.meta as any).y;
                    z += (uChild.meta as any).z;
                    count++;
                }
            }
            
            if (count > 0) {
                const uNode = updatedNodeMap.get(node.id)!;
                // Normalize to radius? Or just keep centroid?
                // Centroid might be deep inside sphere if children span a wide arc.
                // Let's project back to radius to keep them "on the sky".
                const len = Math.sqrt(x*x + y*y + z*z);
                if (len > 0.001) {
                    const scale = radius / len;
                    (uNode.meta as any).x = x * scale;
                    (uNode.meta as any).y = y * scale;
                    (uNode.meta as any).z = z * scale;
                } else {
                    // fallback if children cancel out (unlikely on a hemisphere/sphere section)
                    (uNode.meta as any).x = 0;
                    (uNode.meta as any).y = radius; // zenith?
                    (uNode.meta as any).z = 0;
                }
            }
        };

        // 1. Divisions (L1) - depend on Books (L2) which are already set
        const divisions = model.nodes.filter(n => n.level === 1);
        divisions.forEach(setCentroid);

        // 2. Testaments (L0) - depend on Divisions (L1)
        const testaments = model.nodes.filter(n => n.level === 0);
        testaments.forEach(setCentroid);

        return { ...model, nodes: updatedNodes };
    }

    // --- RADIAL MODE (Existing) ---
    function layoutRadial(nodes: SceneNode[], startAngle: number, totalAngle: number, level: number) {
        if (nodes.length === 0) return;
        nodes.sort((a, b) => a.id.localeCompare(b.id)); // Deterministic

        const totalLeaves = nodes.reduce((sum, n) => sum + (leafCounts.get(n.id) ?? 1), 0);
        let currentAngle = startAngle;
        const currentRadius = level === 0 ? 0 : (radius + (level - 1) * ringSpacing);

        for (const node of nodes) {
            const weight = leafCounts.get(node.id) ?? 1;
            const nodeAngleSpan = (weight / totalLeaves) * totalAngle;
            const midAngle = currentAngle + nodeAngleSpan / 2;

            const updatedNode = updatedNodeMap.get(node.id)!;
            const r = level === 0 ? 0 : currentRadius;
            
            (updatedNode.meta as any).x = Math.cos(midAngle) * r;
            (updatedNode.meta as any).y = Math.sin(midAngle) * r;
            (updatedNode.meta as any).z = 0;
            (updatedNode.meta as any).angle = midAngle;

            const children = childrenMap.get(node.id) ?? [];
            if (children.length > 0) {
                layoutRadial(children, currentAngle, nodeAngleSpan, level + 1);
            }
            currentAngle += nodeAngleSpan;
        }
    }

    layoutRadial(roots, 0, Math.PI * 2, 0);

    return { ...model, nodes: updatedNodes };
}
